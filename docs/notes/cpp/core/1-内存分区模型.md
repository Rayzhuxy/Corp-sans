---
title: 1-内存分区模型
createTime: 2025/06/01 18:07:59
permalink: /cpp/1yrq1lvs/
---
# 内存分区模型

C++程序在执行时，将内存大方向划分为**4 个区域**

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
- 全局区：存放全局变量和**静态变量**以及常量
- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

**内存四区意义：**

不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程

## 1.1 程序运行前

在程序编译后，生成了 exe 可执行程序，**未执行该程序前**分为两个区域

​ **代码区：**

​ 存放 CPU 执行的机器指令

​ 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

​ 代码区是<u>**只读**</u>的，使其只读的原因是防止程序意外地修改了它的指令

​ **全局区：**
​ 全局变量和静态变量存放在此.

​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.

​ ==该区域的数据在程序结束后由操作系统释放==.

**示例：**

```c++
//全局变量
int g_a = 10;
int g_b = 10;

//全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main() {

    //局部变量
    int a = 10;
    int b = 10;

    //打印地址
    cout << "局部变量a地址为： " << (int)&a << endl;
    cout << "局部变量b地址为： " << (int)&b << endl;

    cout << "全局变量g_a地址为： " <<  (int)&g_a << endl;
    cout << "全局变量g_b地址为： " <<  (int)&g_b << endl;

    //静态变量
    static int s_a = 10;
    static int s_b = 10;

    cout << "静态变量s_a地址为： " << (int)&s_a << endl;
    cout << "静态变量s_b地址为： " << (int)&s_b << endl;

    cout << "字符串常量地址为： " << (int)&"hello world" << endl;
    cout << "字符串常量地址为： " << (int)&"hello world1" << endl;

    cout << "全局常量c_g_a地址为： " << (int)&c_g_a << endl;
    cout << "全局常量c_g_b地址为： " << (int)&c_g_b << endl;

    const int c_l_a = 10;
    const int c_l_b = 10;
    cout << "局部常量c_l_a地址为： " << (int)&c_l_a << endl;
    cout << "局部常量c_l_b地址为： " << (int)&c_l_b << endl;

    system("pause");

    return 0;
}
```

输出结果

```C++
局部变量a地址为： 6422044
局部变量b地址为： 6422040   //注意栈区存放从高到低(倒序)
全局变量g_a地址为： 4206608
全局变量g_b地址为： 4206612
静态变量s_a地址为： 4206616
静态变量s_b地址为： 4206620 //全局区顺序
字符串常量地址为： 4210842  //还有\0
字符串常量地址为： 4210854
全局常量c_g_a地址为： 4210692
全局常量c_g_b地址为： 4210696
局部常量c_l_a地址为： 6422036 //注意也是栈
局部常量c_l_b地址为： 6422032
```

> **下面简单概述一下几个变量的区别**

| 类型             | 作用域                   | 生命周期     | 存储位置   | 初始化方式                   | 示例代码                             |
| ---------------- | ------------------------ | ------------ | ---------- | ---------------------------- | ------------------------------------ |
| **局部变量**     | 函数/代码块内部          | 函数调用期间 | 栈         | 未初始化则值为随机垃圾值     | `void func() { int a = 10; }`        |
| **局部常量**     | 函数/代码块内部          | 函数调用期间 | 栈         | 显式初始化(定义后无法修改)   | `void func() { const int b = 20; }`  |
| **全局变量**     | 整个程序                 | 程序运行期间 | 数据段     | 默认初始化为 0               | `int g_var = 30;`                    |
| **全局常量**     | 整个程序                 | 程序运行期间 | 只读数据段 | 显式初始化(定义后无法修改)   | `const int g_const = 40;`            |
| **静态局部变量** | 函数/代码块内部          | 程序运行期间 | 数据段     | 下一次调用时可保持原来的赋值 | `void func() { static int s = 50; }` |
| **静态全局变量** | ==当前文件==（内部链接） | 程序运行期间 | 数据段     | 默认初始化为 0               | `static int s_global = 60;`          |
| **静态全局常量** | ==当前文件==（内部链接） | 程序运行期间 | 只读数据段 | 必须显式初始化               | `static const int s_const = 70;`     |

总结：

- C++中在程序运行前分为全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放全局变量、静态变量、常量
- 常量区中存放 ==const== 修饰的全局常量 和 字符串常量

## 1.2 程序运行后

​ **栈区：**

​ 由编译器自动分配释放, 存放函数的参数值,局部变量等

​ 注意事项：==**不要返回局部变量的地址**==，栈区开辟的数据由编译器自动释放

**示例：**

```c++
int * func()
{
    int a = 10;
    return &a;
}

int main() {

    int *p = func();

    cout << *p << endl;
    cout << *p << endl;

    system("pause");

    return 0;
}
```

​ **堆区：**

​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收

​ 在 C++中主要利用 new 在堆区开辟内存

**示例：**

```c++
int* func()
{
    int* a = new int(5);
    return a;
}

int main() {

    int *p = func();

    cout << p << endl;      //0x1d7fa0
    cout << p << endl;      //0x1d7fa0
    cout << *p << endl;     //5
    delete p;               //仅释放内存，但 p 仍指向原地址
    cout << *p << endl;     //1905232 (Undefined behavior, p is dangling now)

    //下面这句话可能也会报错
    cout << p << endl;      //0x1d7fa0(此时是悬空指针，需要p = nullptr)

    system("pause");

    return 0;
}
```

**总结：**

堆区数据由程序员管理开辟和释放

堆区数据利用 new 关键字进行开辟内存

## 1.3 new 操作符

​ C++中利用==new==操作符在堆区开辟数据

​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==

​ 语法：`new 数据类型`

​ 利用 new 创建的数据，会返回该数据对应的类型的指针

**示例 1： 基本语法**

```c++
int* func()
{
    int* a = new int(10);
    return a;
}

int main() {

    int *p = func();

    cout << *p << endl;
    cout << *p << endl;

    //利用delete释放堆区数据
    delete p;       //同时注意悬空指针的处理

    //cout << *p << endl; //报错，释放的空间不可访问

    system("pause");

    return 0;
}
```

**示例 2：开辟数组**

```c++
//堆区开辟数组
int main() {

    int* arr = new int[10];

    for (int i = 0; i < 10; i++)
    {
        arr[i] = i + 100;
    }

    for (int i = 0; i < 10; i++)
    {
        cout << arr[i] << endl;
    }
    //释放数组 delete 后加 []
    delete[] arr;

    system("pause");

    return 0;
}

```

> _delete arr_ 与 _delete[] arr_ 的区别

| 操作     | 使用场景          | 底层行为                       | 错误使用的后果      |
| -------- | ----------------- | ------------------------------ | ------------------- |
| delete   | 释放**单个对象**  | 调用对象的析构函数（一次）     | 内存泄漏/未定义行为 |
| delete[] | 释放 **对象数组** | 调用每个元素的析构函数（N 次） | 内存泄漏/程序崩溃   |

```C++
class Test {
public:
    ~Test() { cout << "析构" << endl; }
};

int main() {
    Test* p1 = new Test;      // 单个对象
    Test* p2 = new Test[3];   // 数组

    delete p1;    // 输出 1 次 "析构"
    delete[] p2;  // 输出 3 次 "析构"
    return 0;
}
```

输出结果为：

```bash
析构
析构
析构
析构
```
